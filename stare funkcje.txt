#funkcja do szukanie z maską i tolerancją (niepotrzebna)
def szukajztolerancja(oknostart, okno, szukany):
    box1 = szukany.getbbox()
    img = ImageGrab.grab(bbox=oknostart + okno)
    szer = okno[0] - oknostart[0]
    wys = okno[1] - oknostart[1]
    sum = box1[2] * box1[3]
    for a in range(0, szer):
        for b in range(0, wys):
            cordinate2 = a, b
            cordinate1 = 0, 0
            pix1 = img.getpixel(cordinate2)
            pix2 = szukany.getpixel(cordinate1)
            tolerancja = 1

            if fabs(pix1[0] - pix2[0]) <= tolerancja and fabs(pix1[1] - pix2[1]) <= tolerancja and fabs(
                    pix1[2] - pix2[2]) <= tolerancja:
                # print(fabs(pix1[0] - pix2[0]), fabs(pix1[1] - pix2[1]), fabs(pix1[2] - pix2[2]))
                # print(a,b)
                h = 1
                a = 0
                if ((szer - a > box1[2]) and (wys - b > box1[3])):

                    for j in range(0, box1[2]):
                        if (a == 1):
                            break
                        for i in range(0, box1[3]):
                            if (h == sum):
                                return 1
                            else:
                                cordinate1 = j, i
                                cordinate3 = j + cordinate2[0], i + cordinate2[1]
                                if (szukany.getpixel(cordinate1) == pustybit):
                                    h = h + 1
                                    continue
                                else:
                                    pix1 = img.getpixel(cordinate3)
                                    pix2 = szukany.getpixel(cordinate1)
                                    tolerancja = 1
                                    if fabs(pix1[0] - pix2[0]) <= tolerancja and fabs(
                                            pix1[1] - pix2[1]) <= tolerancja and fabs(pix1[2] - pix2[2]) <= tolerancja:
                                        h = h + 1
                                        print(h, "/", sum)
                                        if (h == sum):
                                            return 1
                                    else:
                                        h = 0
                                        a = 1
                                        break
    return 0

#zwykle szukanie starsza wersja(bez tolerancji , bez pixela maski)
def szukajwoknie2(oknostart, okno, szukany):
    PIL.ImageGrab.grab(bbox=None)
    img = ImageGrab.grab()
    box1 = szukany.getbbox()
    h = 0  # ilosc zgodnych bitow
    for a in range(oknostart[0], okno[0]):
        for b in range(oknostart[1], okno[1]):
            koordy2 = a, b
            koordy1 = 0, 0
            if (img.getpixel(koordy2)) == (szukany.getpixel(koordy1)):
                # pierwszy pixel sie zgadza
                for j in range(0, box1[2]):
                    for i in range(0, box1[3]):
                        koordy1 = j, i
                        koordy3 = j + koordy2[0], i + koordy2[1]
                        if img.getpixel(koordy3) == szukany.getpixel(koordy1):
                            h = h + 1
                            if (h == (box1[2]) * (box1[3])):
                                pozycja = koordy3
                                return pozycja
                        else:
                            h = 0
                            break
    return 0

#Do szukanie z formatu cv2
def szukajwoknie2(oknostart, okno, szukany):
    img = pyautogui.screenshot()
    img = cv2.cvtColor(numpy.array(img), cv2.COLOR_RGB2BGR)
    szukanyWys , szukanySzer, channel = szukany.shape
    wys,szer,channel2=img.shape
    sum = szukanyWys*szukanySzer
    for a in range(0, wys):
        for b in range(0, szer):
            cordinate2 = a, b
            cordinate1 = 0, 0
            if (img[cordinate2].tolist()) == (szukany[cordinate1].tolist()):
                h = 1
                a = 0
                for j in range(0, szukanyWys):
                    if (a == 1):
                        break
                    for i in range(0, szukanySzer):
                        if (h == sum):
                            pozycja = cordinate3[1] + oknostart[1],cordinate3[0] + oknostart[0]
                            return pozycja
                        else:
                            cordinate1 = j, i
                            cordinate3 = j + cordinate2[0], i + cordinate2[1]
                            if (szukany[cordinate1].tolist() == pustybit):
                                h = h + 1
                                continue
                            else:
                                if img[cordinate3].tolist() == szukany[cordinate1].tolist():
                                    h = h + 1
                                    if (h == sum):
                                        pozycja =  cordinate3[1] + oknostart[1],cordinate3[0] + oknostart[0]
                                        return pozycja
                                else:
                                    h = 0
                                    a = 1
                                    break
    return 0
	
#Wczytaj zdjęcia by operować nimi w cv2(funkcje activeseartch,find_numbers etc)
def load_images_tocv2(folder):
    images = {}
    for filename in os.listdir(folder):
        img = cv2.imread(os.path.join(folder,filename))
        if img is not None:
            print(filename)
            images[filename] = img
    return images
	
#wykorzystywanie biblioteki do "inteligentnego" szukanie cz1
def active_search(sample, image):
    # pobiera wycinek ze screena i porownuje do duzej probki z folderu
    method = cv2.TM_SQDIFF_NORMED
    small_image = sample
    large_image = image
    # zastosowanie metody by poznac"granice"
    result = cv2.matchTemplate(small_image, large_image, method)
    mn, _, mnLoc, _ = cv2.minMaxLoc(result)
    # Draw the rectangle:
    # koordynaty najlepszego znaleziska
    MPx, MPy = mnLoc
    # Step 2: Get the size of the template. This is the same size as the match.
    trows, tcols = small_image.shape[:2]
    # Przyciecie obrazka do najbardziej dopasowanego
    large_image = large_image[MPy:MPy + trows, MPx:MPx + tcols]
    # tylko jezeli blad jest maly(wykryto czerwone okienko)
    if (mn < 0.25):
        # zwraca tylko czerwone okno
        return large_image
    else:
        # zwraca 0 co ponowi próbe
        return 0
		

#wykorzystywanie biblioteki do "inteligentnego" szukanie cz2	
def which_number(sample, image):
    # pobiera czerwone okno z liczba i porownuje do malej probki z folderu
    method = cv2.TM_SQDIFF_NORMED
    small_image = sample
    large_image = image
    # zastosowanie metody by poznac"granice"
    result = cv2.matchTemplate(small_image, large_image, method)
    mn, _, mnLoc, _ = cv2.minMaxLoc(result)
    # zwroc 1 jezeli maly blad(znaleziono)
    # zwroc 0 jezeli ma szukac dalej
    # tylko jezeli blad jest maly
    if (mn < 0.05):
        print("mn = ", mn)
        return 0
    else:
        return mn
		
		
#obsluga "inteligentego" szukania
def szukajliczb(k, oknoMale1, oknoMale2):
    img = ImageGrab.grab(bbox=oknoMale1 + oknoMale2)
    image = numpy.array(img)
    # Convert RGB to BGR
    image = image[:, :, ::-1].copy()
    probability = []
    szukane = active_search(czerwoneokno, image)
    if isinstance(szukane, int):
        # ilosc  prob przed restartem
        if MULTI == 1:
            if (k > 800):
                return 7
        # ustalenie po ilu powtórzeniach restart
        if (k > 1100):
            return 7
        return 0
    else:
        print("wyskoczylo okno")
        i = 0

        szukaneWys=szukane.shape[0]
        for key in liczby:

            # zabezpieczenie wysokości ( dobra strone warunek? xD)
            if szukaneWys < liczby[key].shape[0]:
                print("pobrano za mala probke by uniknac bledu 'znajduje' 4")
                return 4

            # print("sprawdzam liczbe o indeksie",i)
            probability.append(which_number(liczby[key], szukane))
            if (probability[i] == 0):
                print("znaleziono", key)
                return (i + 1)
            i = i + 1
            # print("szansa",i," = ",probability[i])

        print("nie rozpoznano liczby w oknie, utworzono zrzut wykrycia")
        cv2.imwrite("zrzut.png", szukane)
        # zwraca indeks przykladu ktory byl najpodobniejszy do sprawdzanego
        print("droga eliminacji otrzumano liczbe", probability.index(min(probability)) + 1)
        return probability.index(min(probability)) + 1
	return 0

#STARE MENU
def menu():
    global INFO1
    global INFO2
    global root
    # root = Tk()
    root.title("Wielkoryb v.1.8")
    kolor = "snow3"
    leftFrame = Frame(root, bg=kolor)
    leftFrame.pack(side=LEFT)
    rightFrame = Frame(root)
    rightFrame.pack(side=LEFT)
    middleFrame = Frame(root, bg=kolor)
    middleFrame.pack(side=LEFT)
    INFO1 = StringVar()
    INFO1.set("NIEAKTYWNY")
    INFO2 = StringVar()
    INFO2.set("NIEAKTYWNY")
    label1 = Label(leftFrame, text="Wielkoryb v.1.7", fg="red", bg=kolor,font=10)
    label2 = Label(leftFrame, text="Wystartuj Bota", fg="cyan", bg=kolor)
    label6 = Label(leftFrame, text="DEBUGGER", fg="cyan", bg="red")
    label3 = Label(leftFrame, text="CheckBox", fg="cyan", bg=kolor)
    label5 = Label(leftFrame, text="Wyjscie", fg="cyan", bg=kolor)
    label4 = Label(leftFrame, text="PRINTSCREEN", fg="cyan", bg=kolor)


    button1 = Button(leftFrame, text="START", fg="red", command=lambda : Thread(target=start).start())
    button5 = Button(leftFrame, text="DEBUG", fg="red", command=debugger)
    button2 = Button(leftFrame, text="CheckBox", fg="red", command=checkboxy)
    button4 = Button(leftFrame, text="STOP", fg="red", command=stop)
    button3 = Button(leftFrame, text="PrintScreen", fg="red", command=screen)

    label1.grid(row=0)
    label2.grid(row=1)
    label3.grid(row=2)
    label4.grid(row=3)
    label5.grid(row=4)
    label6.grid(row=5)
    button1.grid(row=1, column=1)
    button2.grid(row=2, column=1)
    button3.grid(row=3, column=1)
    button4.grid(row=4, column=1)
    button5.grid(row=5, column=1)

    Label(rightFrame, textvariable=INFO1, fg="red").pack(side=TOP)
    Label(rightFrame, textvariable=INFO2, fg="red").pack(side=TOP)

    CheckVar = IntVar(value=OTW)
    CheckVar2 = IntVar(value=MULTI)
    CheckVar3 = IntVar(value=ZAPIS)
    CheckVar4 = IntVar(value=USUN)

    check1 = Checkbutton(rightFrame, text="MultiClient", command=mlt, variable=CheckVar2)
    check2 = Checkbutton(rightFrame, text="Otwieranie Rybek", command=otw, variable=CheckVar)
    check3 = Checkbutton(rightFrame, text="ZAPIS PNG", command=zap, variable=CheckVar3)
    check4 = Checkbutton(rightFrame, text="Usuwaj Śmieci", command=usu, variable=CheckVar4)
    check3.pack(side=TOP)
    check1.pack(side=TOP)
    check4.pack(side=TOP)
    check2.pack(side=TOP)

    root.protocol('WM_DELETE_WINDOW', root.quit)
    debuguj()
    root.mainloop()

#STARY DEBUG OKNO
def debuguj():
    global DEBUGGER
    global debug
    OPTIONS = [
        "robak.png",
        "lowienie.png",
        "ryba1.png",
        "ryba2.png",
        "ryba3.png",
        "ryba4.png",
        "ryba5.png",
        "ryba6.png",
        "ryba7.png",
        "ryba8.png",
        "ryba9.png",
        "ryba10.png",
        "ryba11.png",
        "ryba12.png",
        "plaszcz.png",
        "pierscien.png",
        "puste.png",
        "test.png"
    ]
    variable = StringVar(debug)
    variable.set(OPTIONS[0])
    w = OptionMenu(debug, variable, *OPTIONS)
    w.pack()
    debug.title("DEBUGGER v3.1")
    kolor = "gray"
    leftFrame = Frame(debug, bg=kolor)
    leftFrame.pack(side=LEFT)
    rightFrame = Frame(debug)
    rightFrame.pack(side=LEFT)
    middleFrame = Frame(debug, bg=kolor)
    middleFrame.pack(side=LEFT)
    buttons = Button(debug, text="PODMIEN", fg="red", command=lambda: probka(variable.get()))
    buttons.pack()
    button5 = Button(debug, text="TEST2", fg="red", command=test2)
    button5.pack()
    label0 = Label(debug, fg="red", text="1.Wyłącz MultiClient przed debugowaniem")
    label0.pack()
    label1 = Label(debug, fg="red",text="2.Pobierz i nadpisz próbke danego przedmiotu z pierwszego slota EQ/ ikonke lowienia z F4")
    label1.pack()
    label2 = Label(debug, fg="red", text="3.Zaznacz ZapisPNG i zrób Checkboxy a zobaczysz obszar jaki kopiuje debugger(najmniejszy kwadracik)")
    label2.pack()
    label3 = Label(debug, fg="red", text="OPIS POWSZECHNYCH PROBLEMÓW")
    label3.pack()
    label6 = Label(debug, text="Nie wykryto loga - Sprawdz czy w folderze jest dobrze wykonana próbka logo.png", fg="red")
    label6.pack(side=TOP)
    label7 = Label(debug,text="Jeżeli nie masz pewności co do próbki zrób PRINTSCREEN i zastęp próbke swoim wycinkiem", fg="red")
    label7.pack(side=TOP)
    label8 = Label(debug, text="Nie wykryto robaka / wędki (jak up tylko można naprawić debuggerem)", fg="red")
    label8.pack(side=TOP)
    label9 = Label(debug, text="Rusza myszką ale nie klika --> URUCHOM JAKO ADMINISTRATOR", fg="red")
    label9.pack(side=TOP)
    label10 = Label(debug,text="Klika na coś inne niż robak(zdebuguj robaka z 1 slota eq)", fg="red")
    label10.pack(side=TOP)
    label11 = Label(debug, text="Inne Problemy można zgłaszać na adres: www.xd@xd.pl", fg="red")
    label11.pack(side=TOP)


def start2():
    (oknostart1, okno1, oknoMaleS1, oknoMale1, oknoeqS1, oknoeq1, ekipunek1, oknostart2, okno2, oknoMaleS2, oknoMale2,
     oknoeqS2, oknoeq2, ekwipunek2) = checkboxy()

    sprawdzanie = 10
    global INFO1
    global INFO2
    global RESTART
    INFO1.set("STARTOWANIE")
    INFO2.set("STARTOWANIE")
    Tk.update(root)

    koordyrobaka1 = szukajwoknie(oknostart1, okno1, sample["robak.png"])
    if (koordyrobaka1 == 0):
        INFO1.set("nie odnaleziono robaka")
        return 0
    koordylowienia1 = szukajwoknie(oknostart1, okno1, sample["low.png"])
    if (koordylowienia1 == 0):
        INFO1.set("nie odnaleziono wedki")
        return 0

    koordyrobaka2 = szukajwoknie(oknostart2, okno2, sample["robak.png"])
    if (koordyrobaka2 == 0):
        INFO2.set("nie odnaleziono robaka")
        return 0
    koordylowienia2 = szukajwoknie(oknostart2, okno2, sample["low.png"])
    if (koordylowienia2 == 0):
        INFO2.set("nie odnaleziono wedki")
        return 0

    status = 1
    while status == 1:
        time.sleep(3.5)
        INFO1.set("łowienie...")
        INFO2.set("łowienie...")
        Tk.update(root)

        print()
        print("ilosc restartow: ", RESTART)
        pyautogui.moveTo(koordyrobaka1[0], koordyrobaka1[1], 0.2)
        time.sleep(0.2)
        pyautogui.click(button='right')
        pyautogui.moveTo(koordylowienia1[0], koordylowienia1[1], 0.2)
        time.sleep(0.2)
        pyautogui.click(button='right')

        pyautogui.moveTo(koordyrobaka2[0], koordyrobaka2[1], 0.2)
        time.sleep(0.2)
        pyautogui.click(button='right')
        pyautogui.moveTo(koordylowienia2[0], koordylowienia2[1], 0.2)
        time.sleep(0.2)
        pyautogui.click(button='right')

        time.sleep(7)
        INFO1.set("szukanie...")
        INFO2.set("szukanie...")
        Tk.update(root)
        koniec = 0
        lowie1 = 0
        lowie2 = 0
        k = 0
        while (koniec == 0):
            if (lowie1 == 0):
                lowie1 = szukajliczb(k, oknoMaleS1, oknoMale1)
            if (lowie2 == 0):
                lowie2 = szukajliczb(k, oknoMaleS2, oknoMale2)
            k = k + 1
            if (lowie1 == 7):
                print("restart")
                INFO1.set("Restart...")
                Tk.update(root)
                RESTART += 1
                time.sleep(4)
                start2()
            if (lowie2 == 7):
                print("restart")
                INFO2.set("Restart...")
                Tk.update(root)
                RESTART += 1
                time.sleep(4)
                start2()

            if (lowie1 > 0):
                if (lowie1 != 9):
                    spacje(lowie1, koordylowienia1)
                    INFO1.set("WYŁOWIONA")
                    Tk.update(root)
                    lowie1 = 9

            if (lowie2 > 0):
                if (lowie2 != 9):
                    spacje(lowie2, koordylowienia2)
                    INFO1.set("WYŁOWIONA")
                    Tk.update(root)
                    lowie2 = 9

            if (lowie1 == 9):
                if (lowie2 == 9):
                    time.sleep(2)
                    if OTW == 1:
                        INFO1.set("OTWIERANIE")
                        INFO2.set("OTWIERANIE")
                        Tk.update(root)
                        sprawdzanie = sprawdzanie + 1
                        otwieranie(oknoeqS1, oknoeq1, sprawdzanie)
                        otwieranie(oknoeqS2, oknoeq2, sprawdzanie)
                    if (sprawdzanie > 45):
                        if USUN == 1:
                            usun(oknostart1, okno1, oknoeqS1, oknoeq1)
                            usun(oknostart2, okno2, oknoeqS2, oknoeq2)
                        sprawdzanie = 0
                    time.sleep(3)
                    koniec = 1

def screen():
    print("printscreen")
    PIL.ImageGrab.grab(bbox=None)
    img = ImageGrab.grab()
    img.save("screen.png")

def debugger():
    global DEBUGGER
    global debug
    global MULTI
    if DEBUGGER == 0:
        if MULTI == 1:
            print("wylacz MULTIKLIENTA by debugowac")
        DEBUGGER = 1
        debug.deiconify()
        print("DEBUG MODE ON")
    else:
        if DEBUGGER == 1:
            DEBUGGER = 0
            debug.withdraw()
    DEBUGGER = 0
    debug.protocol('WM_DELETE_WINDOW', debug.withdraw)
    debug.withdraw()
    debug.mainloop()